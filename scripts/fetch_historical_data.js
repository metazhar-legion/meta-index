#!/usr/bin/env node

/**
 * Historical Data Fetcher for Web3 Index Fund Backtesting
 * 
 * This script fetches historical price data for S&P 500 and RWA assets
 * from Alpha Vantage API and formats it for use in the backtesting framework.
 * 
 * Usage: 
 * 1. Get a free API key from https://www.alphavantage.co/support/
 * 2. Run: node fetch_historical_data.js YOUR_API_KEY
 */

const fs = require('fs');
const path = require('path');
const https = require('https');

// Configuration
const START_DATE = '2020-01-01';
const END_DATE = '2024-06-30';
const OUTPUT_DIR = path.join(__dirname, '../data/historical');

// Symbols to fetch
// ^GSPC is the S&P 500 index
// Using VTIP as a proxy for RWA (Vanguard Short-Term Inflation-Protected Securities ETF)
const SYMBOLS = {
  'SP500': '^GSPC',
  'RWA': 'VTIP'
};

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

/**
 * Fetch historical daily data from Alpha Vantage
 * @param {string} symbol - Stock symbol
 * @param {string} apiKey - Alpha Vantage API key
 * @returns {Promise<Object>} - Historical price data
 */
async function fetchHistoricalData(symbol, apiKey) {
  return new Promise((resolve, reject) => {
    const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&outputsize=full&apikey=${apiKey}`;
    
    console.log(`Fetching data for ${symbol}...`);
    
    https.get(url, (res) => {
      let data = '';
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        try {
          const jsonData = JSON.parse(data);
          
          // Check if we got an error response
          if (jsonData['Error Message']) {
            reject(new Error(`API Error: ${jsonData['Error Message']}`));
            return;
          }
          
          // Check if we hit API call limit
          if (jsonData['Note']) {
            reject(new Error(`API Limit: ${jsonData['Note']}`));
            return;
          }
          
          if (!jsonData['Time Series (Daily)']) {
            reject(new Error(`No data returned for symbol ${symbol}`));
            return;
          }
          
          resolve(jsonData);
        } catch (error) {
          reject(error);
        }
      });
    }).on('error', (error) => {
      reject(error);
    });
  });
}

/**
 * Process and filter the raw data from Alpha Vantage
 * @param {Object} rawData - Raw data from Alpha Vantage
 * @param {string} startDate - Start date in YYYY-MM-DD format
 * @param {string} endDate - End date in YYYY-MM-DD format
 * @returns {Array} - Processed data array
 */
function processData(rawData, startDate, endDate) {
  const timeSeriesData = rawData['Time Series (Daily)'];
  const startTimestamp = new Date(startDate).getTime() / 1000;
  const endTimestamp = new Date(endDate).getTime() / 1000;
  
  const processedData = [];
  
  for (const dateStr in timeSeriesData) {
    const timestamp = new Date(dateStr).getTime() / 1000;
    
    // Filter by date range
    if (timestamp >= startTimestamp && timestamp <= endTimestamp) {
      const dayData = timeSeriesData[dateStr];
      
      processedData.push({
        date: dateStr,
        timestamp: timestamp,
        open: parseFloat(dayData['1. open']),
        high: parseFloat(dayData['2. high']),
        low: parseFloat(dayData['3. low']),
        close: parseFloat(dayData['4. close']),
        volume: parseFloat(dayData['5. volume'])
      });
    }
  }
  
  // Sort by timestamp ascending
  return processedData.sort((a, b) => a.timestamp - b.timestamp);
}

/**
 * Generate Solidity code for setting up historical data in the HistoricalDataProvider
 * @param {Object} data - Processed data for all symbols
 * @returns {string} - Solidity code
 */
function generateSolidityCode(data) {
  let code = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../../backtesting/data/HistoricalDataProvider.sol";
import "forge-std/console2.sol";

/**
 * @title HistoricalPriceData
 * @notice Contains real historical price data for S&P 500 and RWA assets
 * @dev Generated by fetch_historical_data.js on ${new Date().toISOString()}
 * @dev Data period: ${START_DATE} to ${END_DATE}
 */
library HistoricalPriceData {
    // Asset addresses (using placeholder addresses for demonstration)
    address constant SP500_TOKEN = address(0x2);
    address constant RWA_TOKEN = address(0x3);
    address constant RWA_WRAPPER = address(0x5);
    
    /**
     * @notice Set up historical price data in the HistoricalDataProvider
     * @param dataProvider The HistoricalDataProvider to populate with data
     */
    function setupHistoricalPriceData(HistoricalDataProvider dataProvider) internal {
        // Set up S&P 500 price data
        console2.log("Setting up S&P 500 historical price data...");
`;

  // Generate code for S&P 500
  const sp500Data = data['SP500'];
  const sp500BasePrice = sp500Data[0].close;
  
  code += `
    // Base price: ${sp500BasePrice} on ${sp500Data[0].date}
    uint256 sp500BasePrice = ${Math.round(sp500BasePrice * 1e18)}; // Scaled by 1e18
    
`;

  // Limit the number of data points to avoid contract size issues
  // We'll take one data point per week (every 7 days)
  const weeklyData = sp500Data.filter((day, index) => index % 7 === 0);
  
  for (const day of weeklyData) {
    const priceRatio = day.close / sp500BasePrice;
    const scaledPrice = Math.round(sp500BasePrice * priceRatio * 1e18);
    
    code += `        dataProvider.setAssetPrice(SP500_TOKEN, ${day.timestamp}, ${scaledPrice}); // ${day.date}: ${day.close}\n`;
  }
  
  code += `
        // Set up RWA price data
        console2.log("Setting up RWA historical price data...");
`;

  // Generate code for RWA
  const rwaData = data['RWA'];
  const rwaBasePrice = rwaData[0].close;
  
  code += `
    // Base price: ${rwaBasePrice} on ${rwaData[0].date}
    uint256 rwaBasePrice = ${Math.round(rwaBasePrice * 1e18)}; // Scaled by 1e18
    
`;

  // Limit the number of data points to avoid contract size issues
  // We'll take one data point per week (every 7 days)
  const weeklyRwaData = rwaData.filter((day, index) => index % 7 === 0);
  
  for (const day of weeklyRwaData) {
    const priceRatio = day.close / rwaBasePrice;
    const scaledPrice = Math.round(rwaBasePrice * priceRatio * 1e18);
    
    code += `        dataProvider.setAssetPrice(RWA_TOKEN, ${day.timestamp}, ${scaledPrice}); // ${day.date}: ${day.close}\n`;
  }
  
  code += `
        // Set up yield rates for RWA (assuming 4% annual yield)
        // TODO: Update with historical yield data when available
        console2.log("Setting up RWA yield rates...");
        uint256 rwaYieldRate = 400; // 4% in basis points
        
        // Set yield rate for each quarter
        uint256 startTimestamp = ${sp500Data[0].timestamp};
        for (uint256 i = 0; i < 18; i++) { // 4.5 years, quarterly
            uint256 timestamp = startTimestamp + (i * 90 days);
            dataProvider.setYieldRate(RWA_WRAPPER, timestamp, rwaYieldRate);
        }
        
        console2.log("Historical price data setup complete.");
    }
}

/**
 * @title HistoricalPriceDataChecker
 * @notice Helper contract to check if real historical data is available
 * @dev This contract is used by HistoricalPriceDataLoader to determine whether to use real or placeholder data
 */
library HistoricalPriceDataChecker {
    /**
     * @notice Check if real historical data is available
     * @return True since this file contains real historical data
     */
    function checkForRealData() internal pure returns (bool) {
        return true;
    }
}
`;

  return code;
}

/**
 * Save processed data to JSON files
 * @param {Object} data - Processed data for all symbols
 */
function saveToJson(data) {
  for (const symbol in data) {
    const filePath = path.join(OUTPUT_DIR, `${symbol}_daily.json`);
    fs.writeFileSync(filePath, JSON.stringify(data[symbol], null, 2));
    console.log(`Saved ${symbol} data to ${filePath}`);
  }
}

/**
 * Save Solidity code to file
 * @param {string} code - Generated Solidity code
 */
function saveToSolidity(code) {
  const filePath = path.join(OUTPUT_DIR, 'HistoricalPriceData.sol');
  fs.writeFileSync(filePath, code);
  console.log(`Saved Solidity code to ${filePath}`);
  
  // Also update the HistoricalPriceDataLoader to use the real data
  updateDataLoader();
}

/**
 * Generate the HistoricalPriceDataChecker.sol file
 */
function generateCheckerCode() {
  const code = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title HistoricalPriceDataChecker
 * @notice Helper library to check if real historical data is available
 * @dev Generated by fetch_historical_data.js on ${new Date().toISOString()}
 */
library HistoricalPriceDataChecker {
    /**
     * @notice Check if real historical data is available
     * @return True since this file contains real historical data
     */
    function checkForRealData() internal pure returns (bool) {
        // This function was updated by fetch_historical_data.js
        // It returns true because real historical data is available
        return true;
    }
}`;

  const filePath = path.join(OUTPUT_DIR, 'HistoricalPriceDataChecker.sol');
  fs.writeFileSync(filePath, code);
  console.log(`Generated HistoricalPriceDataChecker.sol at ${filePath}`);
}

/**
 * Main function
 */
async function main() {
  // Get API key from command line argument
  const apiKey = process.argv[2];
  
  if (!apiKey) {
    console.error('Please provide your Alpha Vantage API key as a command line argument');
    console.error('Usage: node fetch_historical_data.js YOUR_API_KEY');
    process.exit(1);
  }
  
  try {
    const data = {};
    
    // Fetch data for each symbol with a delay between requests to avoid rate limiting
    for (const [name, symbol] of Object.entries(SYMBOLS)) {
      try {
        const rawData = await fetchHistoricalData(symbol, apiKey);
        data[name] = processData(rawData, START_DATE, END_DATE);
        console.log(`Successfully processed ${name} (${symbol}) data: ${data[name].length} days`);
        
        // Wait 15 seconds between API calls to avoid rate limiting (free tier limit is 5 calls per minute)
        if (Object.keys(SYMBOLS).length > 1) {
          console.log('Waiting 15 seconds before next API call...');
          await new Promise(resolve => setTimeout(resolve, 15000));
        }
      } catch (error) {
        console.error(`Error fetching data for ${name} (${symbol}):`, error.message);
      }
    }
    
    // Check if we got data for all symbols
    const missingData = Object.keys(SYMBOLS).filter(name => !data[name] || data[name].length === 0);
    if (missingData.length > 0) {
      console.error(`Missing data for: ${missingData.join(', ')}`);
      process.exit(1);
    }
    
    // Save data to JSON files
    saveToJson(data);
    
    // Generate and save Solidity code
    const solidityCode = generateSolidityCode(data);
    saveToSolidity(solidityCode);
    
    // Generate the checker code
    generateCheckerCode();
    
    console.log('Done!');
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

main();
